// Generated by CoffeeScript 1.6.3
var AgentSet, Agents, Box, Breed, Breeds, DeathInterrupt, Dump, Globals, HorzCylinder, Iterator, Layouts, Link, Links, NetLogoException, Nobody, Patch, PatchesOwn, Prims, Shufflerator, Topology, TopologyInterrupt, Torus, Trig, Turtle, TurtlesOwn, Updates, VertCylinder, World, collectUpdates, died, linkBuiltins, noop, patchBuiltins, turtleBuiltins, updated, _ref, _ref1,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __slice = [].slice,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

turtleBuiltins = ["id", "color", "heading", "xcor", "ycor", "shape", "label", "labelcolor", "breed", "hidden", "size", "pensize", "penmode"];

patchBuiltins = ["pxcor", "pycor", "pcolor", "plabel", "plabelcolor"];

linkBuiltins = ["end1", "end2", "lcolor", "llabel", "llabelcolor", "lhidden", "lbreed", "thickness", "lshape", "tiemode", "size", "heading", "midpointx", "midpointy"];

NetLogoException = (function() {
  function NetLogoException(message) {
    this.message = message;
  }

  return NetLogoException;

})();

DeathInterrupt = (function(_super) {
  __extends(DeathInterrupt, _super);

  function DeathInterrupt() {
    _ref = DeathInterrupt.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  return DeathInterrupt;

})(NetLogoException);

TopologyInterrupt = (function(_super) {
  __extends(TopologyInterrupt, _super);

  function TopologyInterrupt() {
    _ref1 = TopologyInterrupt.__super__.constructor.apply(this, arguments);
    return _ref1;
  }

  return TopologyInterrupt;

})(NetLogoException);

Updates = [];

Nobody = {
  toString: function() {
    return "nobody";
  }
};

collectUpdates = function() {
  var result;
  result = Updates.length === 0 ? [
    {
      turtles: {},
      patches: {}
    }
  ] : Updates;
  Updates = [
    {
      turtles: {},
      patches: {},
      links: {},
      observer: {},
      world: {}
    }
  ];
  return result;
};

died = function(agent) {
  var update;
  update = {
    patches: {},
    turtles: {},
    links: {}
  };
  if (agent instanceof Turtle) {
    Updates[0].turtles[agent.id] = {
      WHO: -1
    };
  } else if (agent instanceof Link) {
    Updates[0].links[agent.id] = {
      WHO: -1
    };
  }
};

noop = function() {
  var vars;
  vars = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
};

updated = function() {
  var agentUpdate, agents, obj, update, v, vars, _i, _len;
  obj = arguments[0], vars = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
  update = Updates[0];
  if (obj instanceof Turtle) {
    agents = update.turtles;
  } else if (obj instanceof Patch) {
    agents = update.patches;
  } else if (obj instanceof Link) {
    agents = update.links;
  }
  agentUpdate = agents[obj.id] || {};
  if (agentUpdate['WHO'] < 0) {
    delete agentUpdate['WHO'];
  }
  for (_i = 0, _len = vars.length; _i < _len; _i++) {
    v = vars[_i];
    if (v === "plabelcolor") {
      agentUpdate["PLABEL-COLOR"] = obj[v];
    } else if (v === "breed") {
      agentUpdate["BREED"] = obj[v].name;
    } else if (v === "labelcolor") {
      agentUpdate["LABEL-COLOR"] = obj[v];
    } else if (v === "pensize") {
      agentUpdate["PEN-SIZE"] = obj[v];
    } else if (v === "penmode") {
      agentUpdate["PEN-MODE"] = obj[v];
    } else if (v === "hidden") {
      agentUpdate["HIDDEN?"] = obj[v];
    } else if (v === "tiemode") {
      agentUpdate["TIE-MODE"] = obj[v];
    } else if (v === "id" && !(obj instanceof Link)) {
      agentUpdate["WHO"] = obj[v];
    } else if (v === "end1") {
      agentUpdate["END1"] = obj[v].id;
    } else if (v === "end2") {
      agentUpdate["END2"] = obj[v].id;
    } else if (v === "xcor") {
      agentUpdate["XCOR"] = obj.xcor();
    } else if (v === "ycor") {
      agentUpdate["YCOR"] = obj.ycor();
    } else {
      agentUpdate[v.toUpperCase()] = obj[v];
    }
  }
  agents[obj.id] = agentUpdate;
};

Turtle = (function() {
  Turtle.prototype.vars = [];

  Turtle.prototype._xcor = 0;

  Turtle.prototype._ycor = 0;

  Turtle.prototype._links = [];

  function Turtle(color, heading, xcor, ycor, breed, label, labelcolor, hidden, size, pensize, penmode) {
    var x;
    this.color = color != null ? color : 0;
    this.heading = heading != null ? heading : 0;
    if (xcor == null) {
      xcor = 0;
    }
    if (ycor == null) {
      ycor = 0;
    }
    if (breed == null) {
      breed = Breeds.get("TURTLES");
    }
    this.label = label != null ? label : "";
    this.labelcolor = labelcolor != null ? labelcolor : 9.9;
    this.hidden = hidden != null ? hidden : false;
    this.size = size != null ? size : 1.0;
    this.pensize = pensize != null ? pensize : 1.0;
    this.penmode = penmode != null ? penmode : "up";
    this._xcor = xcor;
    this._ycor = ycor;
    this.breedVars = {};
    this.updateBreed(breed);
    this.vars = (function() {
      var _i, _len, _ref2, _results;
      _ref2 = TurtlesOwn.vars;
      _results = [];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        x = _ref2[_i];
        _results.push(x);
      }
      return _results;
    })();
    this.getPatchHere().arrive(this);
  }

  Turtle.prototype.updateBreed = function(breed) {
    var x, _i, _len, _ref2, _results;
    this.breed = breed;
    this.shape = this.breed.shape();
    if (this.breed !== Breeds.get("TURTLES")) {
      _ref2 = this.breed.vars;
      _results = [];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        x = _ref2[_i];
        if (this.breedVars[x] === void 0) {
          _results.push(this.breedVars[x] = 0);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    }
  };

  Turtle.prototype.xcor = function() {
    return this._xcor;
  };

  Turtle.prototype.setXcor = function(newX) {
    var originPatch;
    originPatch = this.getPatchHere();
    this._xcor = world.topology().wrapX(newX);
    if (originPatch !== this.getPatchHere()) {
      originPatch.leave(this);
      this.getPatchHere().arrive(this);
    }
    return this.refreshLinks();
  };

  Turtle.prototype.ycor = function() {
    return this._ycor;
  };

  Turtle.prototype.setYcor = function(newY) {
    var originPatch;
    originPatch = this.getPatchHere();
    this._ycor = world.topology().wrapY(newY);
    if (originPatch !== this.getPatchHere()) {
      originPatch.leave(this);
      this.getPatchHere().arrive(this);
    }
    return this.refreshLinks();
  };

  Turtle.prototype.setBreed = function(breed) {
    this.updateBreed(breed);
    updated(this, "breed");
    return updated(this, "shape");
  };

  Turtle.prototype.toString = function() {
    return "(" + this.breed.singular + " " + this.id + ")";
  };

  Turtle.prototype.keepHeadingInRange = function() {
    if (this.heading < 0 || this.heading >= 360) {
      this.heading = ((this.heading % 360) + 360) % 360;
    }
  };

  Turtle.prototype.canMove = function(amount) {
    return this.patchAhead(amount) !== Nobody;
  };

  Turtle.prototype.distanceXY = function(x, y) {
    return world.topology().distanceXY(this.xcor(), this.ycor(), x, y);
  };

  Turtle.prototype.distance = function(agent) {
    return world.topology().distance(this.xcor(), this.ycor(), agent);
  };

  Turtle.prototype.faceXY = function(x, y) {
    if (x !== this.xcor() || y !== this.ycor()) {
      this.heading = world.topology().towards(this.xcor(), this.ycor(), x, y);
      return updated(this, "heading");
    }
  };

  Turtle.prototype.face = function(agent) {
    if (agent instanceof Turtle) {
      return this.faceXY(agent.xcor(), agent.ycor());
    } else if (agent instanceof Patch) {
      return this.faceXY(agent.pxcor, agent.pycor);
    }
  };

  Turtle.prototype.inRadius = function(agents, radius) {
    return world.topology().inRadius(this, this.xcor(), this.ycor(), agents, radius);
  };

  Turtle.prototype.patchAt = function(dx, dy) {
    return this.getPatchHere().patchAt(dx, dy);
  };

  Turtle.prototype.turtlesAt = function(dx, dy) {
    return this.getPatchHere().turtlesAt(dx, dy);
  };

  Turtle.prototype.connectedLinks = function(directed, isSource) {
    var me;
    me = this;
    if (directed) {
      return new Agents(world.links().items.map(function(l) {
        if ((l.directed && l.end1 === me && isSource) || (l.directed && l.end2 === me && !isSource)) {
          return l;
        } else {
          return null;
        }
      }).filter(function(o) {
        return o !== null;
      }), Breeds.get("LINKS"));
    } else {
      return new Agents(world.links().items.map(function(l) {
        if ((!l.directed && l.end1 === me) || (!l.directed && l.end2 === me)) {
          return l;
        } else {
          return null;
        }
      }).filter(function(o) {
        return o !== null;
      }), Breeds.get("LINKS"));
    }
  };

  Turtle.prototype.refreshLinks = function() {
    var l, _i, _j, _k, _len, _len1, _len2, _ref2, _ref3, _ref4, _results;
    if (this._links.length > 0) {
      _ref2 = (this.connectedLinks(true, true).items);
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        l = _ref2[_i];
        l.updateEndRelatedVars();
      }
      _ref3 = (this.connectedLinks(true, false).items);
      for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
        l = _ref3[_j];
        l.updateEndRelatedVars();
      }
      _ref4 = (this.connectedLinks(false, false).items);
      _results = [];
      for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {
        l = _ref4[_k];
        _results.push(l.updateEndRelatedVars());
      }
      return _results;
    }
  };

  Turtle.prototype.linkNeighbors = function(directed, isSource) {
    var me;
    me = this;
    if (directed) {
      return new Agents(world.links().items.map(function(l) {
        if (l.directed && l.end1 === me && isSource) {
          return l.end2;
        } else if (l.directed && l.end2 === me && !isSource) {
          return l.end1;
        } else {
          return null;
        }
      }).filter(function(o) {
        return o !== null;
      }), Breeds.get("TURTLES"));
    } else {
      return new Agents(world.links().items.map(function(l) {
        if (!l.directed && l.end1 === me) {
          return l.end2;
        } else if (!l.directed && l.end2 === me) {
          return l.end1;
        } else {
          return null;
        }
      }).filter(function(o) {
        return o !== null;
      }), Breeds.get("TURTLES"));
    }
  };

  Turtle.prototype.isLinkNeighbor = function(directed, isSource, other) {
    return this.linkNeighbors(directed, isSource).items.filter(function(o) {
      return o === other;
    }).length > 0;
  };

  Turtle.prototype.findLinkViaNeighbor = function(directed, isSource, other) {
    var links, me;
    me = this;
    links = [];
    if (directed) {
      links = world.links().items.map(function(l) {
        if ((l.directed && l.end1 === me && l.end2 === other && isSource) || (l.directed && l.end1 === other && l.end2 === me && !isSource)) {
          return l;
        } else {
          return null;
        }
      }).filter(function(o) {
        return o !== null;
      });
    } else {
      if (world.unbreededLinksAreDirected) {
        throw new NetLogoException("LINKS is a directed breed.");
      }
      links = world.links().items.map(function(l) {
        if ((!l.directed && l.end1 === me && l.end2 === other) || (!l.directed && l.end2 === me && l.end1 === other)) {
          return l;
        } else {
          return null;
        }
      }).filter(function(o) {
        return o !== null;
      });
    }
    if (links.length === 0) {
      return Nobody;
    } else {
      return links[0];
    }
  };

  Turtle.prototype.otherEnd = function() {
    if (this === AgentSet.myself().end1) {
      return AgentSet.myself().end2;
    } else {
      return AgentSet.myself().end1;
    }
  };

  Turtle.prototype.patchRightAndAhead = function(angle, amount) {
    var error, heading, newX, newY;
    heading = this.heading + angle;
    if (heading < 0 || heading >= 360) {
      heading = ((heading % 360) + 360) % 360;
    }
    try {
      newX = world.topology().wrapX(this.xcor() + amount * Trig.sin(heading));
      newY = world.topology().wrapY(this.ycor() + amount * Trig.cos(heading));
      return world.getPatchAt(newX, newY);
    } catch (_error) {
      error = _error;
      if (error instanceof TopologyInterrupt) {
        return Nobody;
      } else {
        throw error;
      }
    }
  };

  Turtle.prototype.patchLeftAndAhead = function(angle, amount) {
    return this.patchRightAndAhead(-angle, amount);
  };

  Turtle.prototype.patchAhead = function(amount) {
    return this.patchRightAndAhead(0, amount);
  };

  Turtle.prototype.fd = function(amount) {
    if (amount > 0) {
      while (amount >= 1 && this.canMove(1)) {
        this.jump(1);
        amount -= 1;
      }
      if (amount > 0 && this.canMove(amount)) {
        this.jump(amount);
      }
    } else if (amount < 0) {
      while (amount <= -1 && this.canMove(-1)) {
        this.jump(-1);
        amount += 1;
      }
      if (amount < 0 && this.canMove(amount)) {
        this.jump(amount);
      }
    }
  };

  Turtle.prototype.jump = function(amount) {
    if (this.canMove(amount)) {
      this.setXcor(world.topology().wrapX(this.xcor() + amount * Trig.sin(this.heading)));
      this.setYcor(world.topology().wrapY(this.ycor() + amount * Trig.cos(this.heading)));
      updated(this, "xcor", "ycor");
    }
  };

  Turtle.prototype.right = function(amount) {
    this.heading += amount;
    this.keepHeadingInRange();
    updated(this, "heading");
  };

  Turtle.prototype.setXY = function(x, y) {
    var error, origXcor, origYcor;
    origXcor = this.xcor();
    origYcor = this.ycor();
    try {
      this.setXcor(x);
      this.setYcor(y);
    } catch (_error) {
      error = _error;
      this.setXcor(origXcor);
      this.setYcor(origYcor);
      if (error instanceof TopologyInterrupt) {
        throw new TopologyInterrupt("The point [ " + x + " , " + y + " ] is outside of the boundaries of the world and wrapping is not permitted in one or both directions.");
      } else {
        throw error;
      }
    }
    updated(this, "xcor", "ycor");
  };

  Turtle.prototype.hideTurtle = function(flag) {
    this.hidden = flag;
    updated(this, "hidden");
  };

  Turtle.prototype.isBreed = function(breedName) {
    return this.breed.name === breedName;
  };

  Turtle.prototype.die = function() {
    var error, l, _i, _len, _ref2;
    if (this.id !== -1) {
      world.removeTurtle(this.id);
      died(this);
      _ref2 = world.links().items;
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        l = _ref2[_i];
        try {
          if (l.end1.id === this.id || l.end2.id === this.id) {
            l.die();
          }
        } catch (_error) {
          error = _error;
          if (!(error instanceof DeathInterrupt)) {
            throw error;
          }
        }
      }
      this.id = -1;
      this.getPatchHere().leave(this);
    }
    throw new DeathInterrupt("Call only from inside an askAgent block");
  };

  Turtle.prototype.getTurtleVariable = function(n) {
    if (n < turtleBuiltins.length) {
      if (n === 3) {
        return this.xcor();
      } else if (n === 4) {
        return this.ycor();
      } else if (n === 8) {
        return world.turtlesOfBreed(this.breed.name);
      } else {
        return this[turtleBuiltins[n]];
      }
    } else {
      return this.vars[n - turtleBuiltins.length];
    }
  };

  Turtle.prototype.setTurtleVariable = function(n, v) {
    if (n < turtleBuiltins.length) {
      if (n === 3) {
        this.setXcor(v);
      } else if (n === 4) {
        this.setYcor(v);
      } else {
        if (n === 5) {
          v = v.toLowerCase();
        }
        this[turtleBuiltins[n]] = v;
        if (n === 2) {
          this.keepHeadingInRange();
        }
      }
      return updated(this, turtleBuiltins[n]);
    } else {
      return this.vars[n - turtleBuiltins.length] = v;
    }
  };

  Turtle.prototype.getBreedVariable = function(n) {
    return this.breedVars[n];
  };

  Turtle.prototype.setBreedVariable = function(n, v) {
    return this.breedVars[n] = v;
  };

  Turtle.prototype.getPatchHere = function() {
    return world.getPatchAt(this.xcor(), this.ycor());
  };

  Turtle.prototype.getPatchVariable = function(n) {
    return this.getPatchHere().getPatchVariable(n);
  };

  Turtle.prototype.setPatchVariable = function(n, v) {
    return this.getPatchHere().setPatchVariable(n, v);
  };

  Turtle.prototype.getNeighbors = function() {
    return this.getPatchHere().getNeighbors();
  };

  Turtle.prototype.getNeighbors4 = function() {
    return this.getPatchHere().getNeighbors4();
  };

  Turtle.prototype.turtlesHere = function() {
    return this.getPatchHere().turtlesHere();
  };

  Turtle.prototype.breedHere = function(breedName) {
    return this.getPatchHere().breedHere(breedName);
  };

  Turtle.prototype.hatch = function(n, breedName) {
    var breed, newTurtles, num, t, v, _i, _j, _ref2;
    breed = breedName ? Breeds.get(breedName) : this.breed;
    newTurtles = [];
    for (num = _i = 0; 0 <= n ? _i < n : _i > n; num = 0 <= n ? ++_i : --_i) {
      t = new Turtle(this.color, this.heading, this.xcor(), this.ycor(), breed, this.label, this.labelcolor, this.hidden, this.size, this.pensize, this.penmode);
      for (v = _j = 0, _ref2 = TurtlesOwn.vars.length; 0 <= _ref2 ? _j <= _ref2 : _j >= _ref2; v = 0 <= _ref2 ? ++_j : --_j) {
        t.setTurtleVariable(turtleBuiltins.length + v, this.getTurtleVariable(turtleBuiltins.length + v));
      }
      newTurtles.push(world.createTurtle(t));
    }
    return new Agents(newTurtles, breed);
  };

  Turtle.prototype.moveTo = function(agent) {
    if (agent instanceof Turtle) {
      return this.setXY(agent.xcor(), agent.ycor());
    } else if (agent instanceof Patch) {
      return this.setXY(agent.pxcor, agent.pycor);
    }
  };

  Turtle.prototype.watchme = function() {
    return world.watch(this);
  };

  Turtle.prototype._removeLink = function(l) {
    return this._links.splice(this._links.indexOf(l));
  };

  return Turtle;

})();

Patch = (function() {
  Patch.prototype.vars = [];

  function Patch(id, pxcor, pycor, pcolor, plabel, plabelcolor) {
    var x;
    this.id = id;
    this.pxcor = pxcor;
    this.pycor = pycor;
    this.pcolor = pcolor != null ? pcolor : 0.0;
    this.plabel = plabel != null ? plabel : "";
    this.plabelcolor = plabelcolor != null ? plabelcolor : 9.9;
    this.vars = (function() {
      var _i, _len, _ref2, _results;
      _ref2 = PatchesOwn.vars;
      _results = [];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        x = _ref2[_i];
        _results.push(x);
      }
      return _results;
    })();
    this.turtles = [];
  }

  Patch.prototype.toString = function() {
    return "(patch " + this.pxcor + " " + this.pycor + ")";
  };

  Patch.prototype.getPatchVariable = function(n) {
    if (n < patchBuiltins.length) {
      return this[patchBuiltins[n]];
    } else {
      return this.vars[n - patchBuiltins.length];
    }
  };

  Patch.prototype.setPatchVariable = function(n, v) {
    if (n < patchBuiltins.length) {
      this[patchBuiltins[n]] = v;
      if (patchBuiltins[n] === "pcolor" && v !== 0) {
        world.patchesAllBlack(false);
      }
      return updated(this, patchBuiltins[n]);
    } else {
      return this.vars[n - patchBuiltins.length] = v;
    }
  };

  Patch.prototype.leave = function(t) {
    return this.turtles = this.turtles.filter(function(o) {
      return o.id !== t.id;
    });
  };

  Patch.prototype.arrive = function(t) {
    return this.turtles.push(t);
  };

  Patch.prototype.distanceXY = function(x, y) {
    return world.topology().distanceXY(this.pxcor, this.pycor, x, y);
  };

  Patch.prototype.distance = function(agent) {
    return world.topology().distance(this.pxcor, this.pycor, agent);
  };

  Patch.prototype.turtlesHere = function() {
    return new Agents(this.turtles, Breeds.get("TURTLES"));
  };

  Patch.prototype.getNeighbors = function() {
    return world.getNeighbors(this.pxcor, this.pycor);
  };

  Patch.prototype.getNeighbors4 = function() {
    return world.getNeighbors4(this.pxcor, this.pycor);
  };

  Patch.prototype.sprout = function(n, breedName) {
    var breed, num;
    breed = "" === breedName ? Breeds.get("TURTLES") : Breeds.get(breedName);
    return new Agents((function() {
      var _i, _results;
      _results = [];
      for (num = _i = 0; 0 <= n ? _i < n : _i > n; num = 0 <= n ? ++_i : --_i) {
        _results.push(world.createTurtle(new Turtle(5 + 10 * Random.nextInt(14), Random.nextInt(360), this.pxcor, this.pycor, breed)));
      }
      return _results;
    }).call(this));
  };

  Patch.prototype.breedHere = function(breedName) {
    var breed, t;
    breed = Breeds.get(breedName);
    return new Agents((function() {
      var _i, _len, _ref2, _results;
      _ref2 = this.turtles;
      _results = [];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        t = _ref2[_i];
        if (t.breed === breed) {
          _results.push(t);
        }
      }
      return _results;
    }).call(this), breed);
  };

  Patch.prototype.turtlesAt = function(dx, dy) {
    return this.patchAt(dx, dy).turtlesHere();
  };

  Patch.prototype.patchAt = function(dx, dy) {
    var error, newX, newY;
    try {
      newX = world.topology().wrapX(this.pxcor + dx);
      newY = world.topology().wrapY(this.pycor + dy);
      return world.getPatchAt(newX, newY);
    } catch (_error) {
      error = _error;
      if (error instanceof TopologyInterrupt) {
        return Nobody;
      } else {
        throw error;
      }
    }
  };

  Patch.prototype.watchme = function() {
    return world.watch(this);
  };

  return Patch;

})();

Links = {
  compare: function(a, b) {
    if (a === b) {
      return 0;
    } else if (a.end1.id < b.end1.id) {
      return -1;
    } else if (a.end1.id > b.end1.id) {
      return 1;
    } else if (a.end2.id < b.end2.id) {
      return -1;
    } else if (a.end2.id > b.end2.id) {
      return 1;
    } else if (a.breed === b.breed) {
      return 0;
    } else if (a.breed === Breeds.get("LINKS")) {
      return -1;
    } else if (b.breed === Breeds.get("LINKS")) {
      return 1;
    } else {
      throw new Error("We have yet to implement link breed comparison");
    }
  }
};

Link = (function() {
  Link.prototype.color = 5;

  Link.prototype.label = "";

  Link.prototype.labelcolor = 9.9;

  Link.prototype.hidden = false;

  Link.prototype.shape = "default";

  Link.prototype.thickness = 0;

  Link.prototype.tiemode = "none";

  Link.prototype.xcor = function() {};

  Link.prototype.ycor = function() {};

  function Link(id, directed, end1, end2) {
    this.id = id;
    this.directed = directed;
    this.end1 = end1;
    this.end2 = end2;
    this.breed = Breeds.get("LINKS");
    this.end1._links.push(this);
    this.end2._links.push(this);
    this.updateEndRelatedVars();
  }

  Link.prototype.getLinkVariable = function(n) {
    if (n < linkBuiltins.length) {
      return this[linkBuiltins[n]];
    } else {
      return this.vars[n - linkBuiltins.length];
    }
  };

  Link.prototype.setLinkVariable = function(n, v) {
    if (n < linkBuiltins.length) {
      this[linkBuiltins[n]] = v;
      return updated(this, linkBuiltins[n]);
    } else {
      return this.vars[n - linkBuiltins.length] = v;
    }
  };

  Link.prototype.die = function() {
    if (this.id !== -1) {
      this.end1._removeLink(this);
      this.end2._removeLink(this);
      world.removeLink(this.id);
      died(this);
      this.id = -1;
    }
    throw new DeathInterrupt("Call only from inside an askAgent block");
  };

  Link.prototype.getTurtleVariable = function(n) {
    return this[turtleBuiltins[n]];
  };

  Link.prototype.setTurtleVariable = function(n, v) {
    this[turtleBuiltins[n]] = v;
    return updated(this, turtleBuiltins[n]);
  };

  Link.prototype.bothEnds = function() {
    return new Agents([this.end1, this.end2], Breeds.get("TURTLES"));
  };

  Link.prototype.otherEnd = function() {
    if (this.end1 === AgentSet.myself()) {
      return this.end2;
    } else {
      return this.end1;
    }
  };

  Link.prototype.updateEndRelatedVars = function() {
    this.heading = world.topology().towards(this.end1.xcor(), this.end1.ycor(), this.end2.xcor(), this.end2.ycor());
    this.size = world.topology().distanceXY(this.end1.xcor(), this.end1.ycor(), this.end2.xcor(), this.end2.ycor());
    this.midpointx = world.topology().midpointx(this.end1.xcor(), this.end2.xcor());
    this.midpointy = world.topology().midpointy(this.end1.ycor(), this.end2.ycor());
    return updated.apply(null, [this].concat(__slice.call(linkBuiltins)));
  };

  Link.prototype.toString = function() {
    return "(" + this.breed.singular + " " + this.end1.id + " " + this.end2.id + ")";
  };

  return Link;

})();

World = (function() {
  var _links, _nextLinkId, _nextTurtleId, _patches, _patchesAllBlack, _ticks, _timer, _topology, _turtles;

  _nextLinkId = 0;

  _nextTurtleId = 0;

  _turtles = [];

  _patches = [];

  _links = [];

  _topology = null;

  _ticks = -1;

  _timer = Date.now();

  _patchesAllBlack = true;

  function World(minPxcor, maxPxcor, minPycor, maxPycor, patchSize, wrappingAllowedInY, wrappingAllowedInX, turtleShapeList, linkShapeList, interfaceGlobalCount) {
    this.minPxcor = minPxcor;
    this.maxPxcor = maxPxcor;
    this.minPycor = minPycor;
    this.maxPycor = maxPycor;
    this.patchSize = patchSize;
    this.wrappingAllowedInY = wrappingAllowedInY;
    this.wrappingAllowedInX = wrappingAllowedInX;
    this.interfaceGlobalCount = interfaceGlobalCount;
    this.perspective = 0;
    this.targetAgent = null;
    collectUpdates();
    Updates.push({
      world: {
        0: {
          worldWidth: Math.abs(this.minPxcor - this.maxPxcor) + 1,
          worldHeight: Math.abs(this.minPycor - this.maxPycor) + 1,
          minPxcor: this.minPxcor,
          minPycor: this.minPycor,
          maxPxcor: this.maxPxcor,
          maxPycor: this.maxPycor,
          linkBreeds: "XXX IMPLEMENT ME",
          linkShapeList: linkShapeList,
          patchSize: this.patchSize,
          patchesAllBlack: _patchesAllBlack,
          patchesWithLabels: 0,
          ticks: _ticks,
          turtleBreeds: "XXX IMPLEMENT ME",
          turtleShapeList: turtleShapeList,
          unbreededLinksAreDirected: false,
          wrappingAllowedInX: this.wrappingAllowedInX,
          wrappingAllowedInY: this.wrappingAllowedInY
        }
      }
    });
    this.updatePerspective();
    this.resize(this.minPxcor, this.maxPxcor, this.minPycor, this.maxPycor);
  }

  World.prototype.createPatches = function() {
    var nested, p, x, y, _i, _len, _ref2, _results;
    nested = (function() {
      var _i, _ref2, _ref3, _results;
      _results = [];
      for (y = _i = _ref2 = this.maxPycor, _ref3 = this.minPycor; _ref2 <= _ref3 ? _i <= _ref3 : _i >= _ref3; y = _ref2 <= _ref3 ? ++_i : --_i) {
        _results.push((function() {
          var _j, _ref4, _ref5, _results1;
          _results1 = [];
          for (x = _j = _ref4 = this.minPxcor, _ref5 = this.maxPxcor; _ref4 <= _ref5 ? _j <= _ref5 : _j >= _ref5; x = _ref4 <= _ref5 ? ++_j : --_j) {
            _results1.push(new Patch((this.width() * (this.maxPycor - y)) + x - this.minPxcor, x, y));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    }).call(this);
    _patches = (_ref2 = []).concat.apply(_ref2, nested);
    _results = [];
    for (_i = 0, _len = _patches.length; _i < _len; _i++) {
      p = _patches[_i];
      _results.push(updated(p, "pxcor", "pycor", "pcolor", "plabel", "plabelcolor"));
    }
    return _results;
  };

  World.prototype.topology = function() {
    return _topology;
  };

  World.prototype.links = function() {
    return new Agents(_links.sort(Links.compare));
  };

  World.prototype.turtles = function() {
    return new Agents(_turtles, Breeds.get("TURTLES"));
  };

  World.prototype.turtlesOfBreed = function(breedName) {
    var breed;
    breed = Breeds.get(breedName);
    return new Agents(_turtles.filter(function(t) {
      return t.breed === breed;
    }), breed);
  };

  World.prototype.patches = function() {
    return new Agents(_patches);
  };

  World.prototype.resetTimer = function() {
    return _timer = Date.now();
  };

  World.prototype.resetTicks = function() {
    _ticks = 0;
    return Updates.push({
      world: {
        0: {
          ticks: _ticks
        }
      }
    });
  };

  World.prototype.clearTicks = function() {
    _ticks = -1;
    return Updates.push({
      world: {
        0: {
          ticks: _ticks
        }
      }
    });
  };

  World.prototype.resize = function(minPxcor, maxPxcor, minPycor, maxPycor) {
    var error, t, _i, _len, _ref2;
    if (minPxcor > 0 || maxPxcor < 0 || minPycor > 0 || maxPycor < 0) {
      throw new NetLogoException("You must include the point (0, 0) in the world.");
    }
    this.minPxcor = minPxcor;
    this.maxPxcor = maxPxcor;
    this.minPycor = minPycor;
    this.maxPycor = maxPycor;
    if (this.wrappingAllowedInX && this.wrappingAllowedInY) {
      _topology = new Torus(this.minPxcor, this.maxPxcor, this.minPycor, this.maxPycor);
    } else if (this.wrappingAllowedInX) {
      _topology = new VertCylinder(this.minPxcor, this.maxPxcor, this.minPycor, this.maxPycor);
    } else if (this.wrappingAllowedInY) {
      _topology = new HorzCylinder(this.minPxcor, this.maxPxcor, this.minPycor, this.maxPycor);
    } else {
      _topology = new Box(this.minPxcor, this.maxPxcor, this.minPycor, this.maxPycor);
    }
    _ref2 = this.turtles().items;
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      t = _ref2[_i];
      try {
        t.die();
      } catch (_error) {
        error = _error;
        if (!(error instanceof DeathInterrupt)) {
          throw error;
        }
      }
    }
    this.createPatches();
    return Updates.push({
      world: {
        0: {
          worldWidth: Math.abs(this.minPxcor - this.maxPxcor) + 1,
          worldHeight: Math.abs(this.minPycor - this.maxPycor) + 1,
          minPxcor: this.minPxcor,
          minPycor: this.minPycor,
          maxPxcor: this.maxPxcor,
          maxPycor: this.maxPycor
        }
      }
    });
  };

  World.prototype.tick = function() {
    if (_ticks === -1) {
      throw new NetLogoException("The tick counter has not been started yet. Use RESET-TICKS.");
    }
    _ticks++;
    return Updates.push({
      world: {
        0: {
          ticks: _ticks
        }
      }
    });
  };

  World.prototype.tickAdvance = function(n) {
    if (_ticks === -1) {
      throw new NetLogoException("The tick counter has not been started yet. Use RESET-TICKS.");
    }
    if (n < 0) {
      throw new NetLogoException("Cannot advance the tick counter by a negative amount.");
    }
    _ticks += n;
    return Updates.push({
      world: {
        0: {
          ticks: _ticks
        }
      }
    });
  };

  World.prototype.timer = function() {
    return (Date.now() - _timer) / 1000;
  };

  World.prototype.ticks = function() {
    if (_ticks === -1) {
      throw new NetLogoException("The tick counter has not been started yet. Use RESET-TICKS.");
    }
    return _ticks;
  };

  World.prototype.width = function() {
    return 1 + this.maxPxcor - this.minPxcor;
  };

  World.prototype.height = function() {
    return 1 + this.maxPycor - this.minPycor;
  };

  World.prototype.getPatchAt = function(x, y) {
    var index;
    index = (this.maxPycor - StrictMath.round(y)) * this.width() + (StrictMath.round(x) - this.minPxcor);
    return _patches[index];
  };

  World.prototype.getTurtle = function(id) {
    var filteredTurtles;
    filteredTurtles = this.turtles().items.filter(function(t) {
      return t.id === id;
    });
    if (filteredTurtles.length === 0) {
      return Nobody;
    } else {
      return filteredTurtles[0];
    }
  };

  World.prototype.getTurtleOfBreed = function(breedName, id) {
    var filteredTurtles;
    filteredTurtles = this.turtlesOfBreed(breedName).items.filter(function(t) {
      return t.id === id;
    });
    if (filteredTurtles.length === 0) {
      return Nobody;
    } else {
      return filteredTurtles[0];
    }
  };

  World.prototype.removeLink = function(id) {
    _links = this.links().items.filter(function(l) {
      return l.id !== id;
    });
    if (_links.length === 0) {
      this.unbreededLinksAreDirected = false;
      Updates.push({
        world: {
          0: {
            unbreededLinksAreDirected: false
          }
        }
      });
    }
  };

  World.prototype.removeTurtle = function(id) {
    _turtles = this.turtles().items.filter(function(t) {
      return t.id !== id;
    });
  };

  World.prototype.patchesAllBlack = function(val) {
    _patchesAllBlack = val;
    return Updates.push({
      world: {
        0: {
          patchesAllBlack: _patchesAllBlack
        }
      }
    });
  };

  World.prototype.clearAll = function() {
    var error, t, _i, _len, _ref2;
    Globals.clear(this.interfaceGlobalCount);
    _ref2 = this.turtles().items;
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      t = _ref2[_i];
      try {
        t.die();
      } catch (_error) {
        error = _error;
        if (!(error instanceof DeathInterrupt)) {
          throw error;
        }
      }
    }
    this.createPatches();
    _nextTurtleId = 0;
    _nextLinkId = 0;
    this.patchesAllBlack(true);
    this.clearTicks();
    clearPlots();
  };

  World.prototype.createTurtle = function(t) {
    t.id = _nextTurtleId++;
    updated.apply(null, [t].concat(__slice.call(turtleBuiltins)));
    _turtles.push(t);
    return t;
  };

  World.prototype.createLink = function(directed, from, to) {
    var end1, end2, l;
    if (from.id < to.id || directed) {
      end1 = from;
      end2 = to;
    } else {
      end1 = to;
      end2 = from;
    }
    if (Nobody === this.getLink(end1.id, end2.id)) {
      l = new Link(_nextLinkId++, directed, end1, end2);
      updated.apply(null, [l].concat(__slice.call(linkBuiltins)));
      updated.apply(null, [l].concat(__slice.call(turtleBuiltins.slice(1))));
      _links.push(l);
      return l;
    } else {
      return Nobody;
    }
  };

  World.prototype.createOrderedTurtles = function(n, breedName) {
    var num;
    return new Agents((function() {
      var _i, _results;
      _results = [];
      for (num = _i = 0; 0 <= n ? _i < n : _i > n; num = 0 <= n ? ++_i : --_i) {
        _results.push(this.createTurtle(new Turtle((10 * num + 5) % 140, (360 * num) / n, 0, 0, Breeds.get(breedName))));
      }
      return _results;
    }).call(this));
  };

  World.prototype.createTurtles = function(n, breedName) {
    var num;
    return new Agents((function() {
      var _i, _results;
      _results = [];
      for (num = _i = 0; 0 <= n ? _i < n : _i > n; num = 0 <= n ? ++_i : --_i) {
        _results.push(this.createTurtle(new Turtle(5 + 10 * Random.nextInt(14), Random.nextInt(360), 0, 0, Breeds.get(breedName))));
      }
      return _results;
    }).call(this));
  };

  World.prototype.getNeighbors = function(pxcor, pycor) {
    return this.topology().getNeighbors(pxcor, pycor);
  };

  World.prototype.getNeighbors4 = function(pxcor, pycor) {
    return this.topology().getNeighbors4(pxcor, pycor);
  };

  World.prototype.createDirectedLink = function(from, to) {
    this.unbreededLinksAreDirected = true;
    Updates.push({
      world: {
        0: {
          unbreededLinksAreDirected: true
        }
      }
    });
    return this.createLink(true, from, to);
  };

  World.prototype.createDirectedLinks = function(source, others) {
    var t;
    this.unbreededLinksAreDirected = true;
    Updates.push({
      world: {
        0: {
          unbreededLinksAreDirected: true
        }
      }
    });
    return new Agents(((function() {
      var _i, _len, _ref2, _results;
      _ref2 = others.items;
      _results = [];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        t = _ref2[_i];
        _results.push(this.createLink(true, source, t));
      }
      return _results;
    }).call(this)).filter(function(o) {
      return o !== Nobody;
    }), Breeds.get("LINKS"));
  };

  World.prototype.createReverseDirectedLinks = function(source, others) {
    var t;
    this.unbreededLinksAreDirected = true;
    Updates.push({
      world: {
        0: {
          unbreededLinksAreDirected: true
        }
      }
    });
    return new Agents(((function() {
      var _i, _len, _ref2, _results;
      _ref2 = others.items;
      _results = [];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        t = _ref2[_i];
        _results.push(this.createLink(true, t, source));
      }
      return _results;
    }).call(this)).filter(function(o) {
      return o !== Nobody;
    }), Breeds.get("LINKS"));
  };

  World.prototype.createUndirectedLink = function(source, other) {
    return this.createLink(false, source, other);
  };

  World.prototype.createUndirectedLinks = function(source, others) {
    var t;
    return new Agents(((function() {
      var _i, _len, _ref2, _results;
      _ref2 = others.items;
      _results = [];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        t = _ref2[_i];
        _results.push(this.createLink(false, source, t));
      }
      return _results;
    }).call(this)).filter(function(o) {
      return o !== Nobody;
    }), Breeds.get("LINKS"));
  };

  World.prototype.getLink = function(fromId, toId) {
    var filteredLinks;
    filteredLinks = this.links().items.filter(function(l) {
      return l.end1.id === fromId && l.end2.id === toId;
    });
    if (filteredLinks.length === 0) {
      return Nobody;
    } else {
      return filteredLinks[0];
    }
  };

  World.prototype.updatePerspective = function() {
    return Updates.push({
      observer: {
        0: {
          perspective: this.perspective,
          targetAgent: this.targetAgent
        }
      }
    });
  };

  World.prototype.watch = function(agent) {
    var agentId, agentKind;
    this.perspective = 3;
    agentKind = 0;
    agentId = -1;
    if (agent instanceof Turtle) {
      agentKind = 1;
      agentId = agent.id;
    } else if (agent instanceof Patch) {
      agentKind = 2;
      agentId = agent.id;
    }
    this.targetAgent = [agentKind, agentId];
    return this.updatePerspective();
  };

  World.prototype.resetPerspective = function() {
    this.perspective = 0;
    this.targetAgent = null;
    return this.updatePerspective();
  };

  return World;

})();

AgentSet = {
  count: function(x) {
    return x.items.length;
  },
  any: function(x) {
    return x.items.length > 0;
  },
  all: function(x, f) {
    var a, _i, _len, _ref2;
    _ref2 = x.items;
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      a = _ref2[_i];
      if (!this.askAgent(a, f)) {
        return false;
      }
    }
    return true;
  },
  _self: 0,
  _myself: 0,
  self: function() {
    return this._self;
  },
  myself: function() {
    if (this._myself !== 0) {
      return this._myself;
    } else {
      throw new NetLogoException("There is no agent for MYSELF to refer to.");
    }
  },
  askAgent: function(a, f) {
    var error, oldAgent, oldMyself, res;
    oldMyself = this._myself;
    oldAgent = this._self;
    this._myself = this._self;
    this._self = a;
    try {
      res = f();
    } catch (_error) {
      error = _error;
      if (!(error instanceof DeathInterrupt)) {
        throw error;
      }
    }
    this._self = oldAgent;
    this._myself = oldMyself;
    return res;
  },
  ask: function(agentsOrAgent, shuffle, f) {
    var a, agents, iter;
    if (agentsOrAgent.items) {
      agents = agentsOrAgent.items;
    } else {
      agents = [agentsOrAgent];
    }
    iter = shuffle ? new Shufflerator(agents) : new Iterator(agents);
    while (iter.hasNext()) {
      a = iter.next();
      this.askAgent(a, f);
    }
    if (this._self.id && this._self.id === -1) {
      throw new DeathInterrupt;
    }
  },
  agentFilter: function(agents, f) {
    var a;
    return new Agents((function() {
      var _i, _len, _ref2, _results;
      _ref2 = agents.items;
      _results = [];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        a = _ref2[_i];
        if (this.askAgent(a, f)) {
          _results.push(a);
        }
      }
      return _results;
    }).call(this));
  },
  of: function(agentsOrAgent, f) {
    var a, agents, isagentset, iter, result;
    isagentset = agentsOrAgent.items;
    if (isagentset) {
      agents = agentsOrAgent.items;
    } else {
      agents = [agentsOrAgent];
    }
    result = [];
    iter = new Shufflerator(agents);
    while (iter.hasNext()) {
      a = iter.next();
      result.push(this.askAgent(a, f));
    }
    if (isagentset) {
      return result;
    } else {
      return result[0];
    }
  },
  oneOf: function(agentsOrList) {
    var isagentset, l;
    isagentset = agentsOrList.items;
    if (isagentset) {
      l = agentsOrList.items;
    } else {
      l = agentsOrList;
    }
    if (l.length === 0) {
      return Nobody;
    } else {
      return l[Random.nextInt(l.length)];
    }
  },
  nOf: function(resultSize, agentsOrList) {
    var i, index1, index2, items, j, result;
    items = agentsOrList.items;
    if (!items) {
      throw new Error("n-of not implemented on lists yet");
    }
    return new Agents((function() {
      var _ref2;
      switch (resultSize) {
        case 0:
          return [];
        case 1:
          return [items[Random.nextInt(items.length)]];
        case 2:
          index1 = Random.nextInt(items.length);
          index2 = Random.nextInt(items.length - 1);
          _ref2 = index2 >= index1 ? [index1, index2 + 1] : [index2, index1], index1 = _ref2[0], index2 = _ref2[1];
          return [items[index1], items[index2]];
        default:
          i = 0;
          j = 0;
          result = [];
          while (j < resultSize) {
            if (Random.nextInt(items.length - i) < resultSize - j) {
              result.push(items[i]);
              j += 1;
            }
            i += 1;
          }
          return result;
      }
    })());
  },
  turtlesOn: function(agentsOrAgent) {
    var agent, agents, turtles, _ref2;
    if (agentsOrAgent.items) {
      agents = agentsOrAgent.items;
    } else {
      agents = [agentsOrAgent];
    }
    turtles = (_ref2 = []).concat.apply(_ref2, (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = agents.length; _i < _len; _i++) {
        agent = agents[_i];
        _results.push(agent.turtlesHere().items);
      }
      return _results;
    })());
    return new Agents(turtles, agentsOrAgent.breed);
  },
  die: function() {
    return this._self.die();
  },
  connectedLinks: function(directed, isSource) {
    return this._self.connectedLinks(directed, isSource);
  },
  linkNeighbors: function(directed, isSource) {
    return this._self.linkNeighbors(directed, isSource);
  },
  isLinkNeighbor: function(directed, isSource) {
    var t;
    t = this._self;
    return function(other) {
      return t.isLinkNeighbor(directed, isSource, other);
    };
  },
  findLinkViaNeighbor: function(directed, isSource) {
    var t;
    t = this._self;
    return function(other) {
      return t.findLinkViaNeighbor(directed, isSource, other);
    };
  },
  getTurtleVariable: function(n) {
    return this._self.getTurtleVariable(n);
  },
  setTurtleVariable: function(n, v) {
    return this._self.setTurtleVariable(n, v);
  },
  getLinkVariable: function(n) {
    return this._self.getLinkVariable(n);
  },
  setLinkVariable: function(n, v) {
    return this._self.setLinkVariable(n, v);
  },
  getBreedVariable: function(n) {
    return this._self.getBreedVariable(n);
  },
  setBreedVariable: function(n, v) {
    return this._self.setBreedVariable(n, v);
  },
  setBreed: function(agentSet) {
    return this._self.setBreed(agentSet.breed);
  },
  getPatchVariable: function(n) {
    return this._self.getPatchVariable(n);
  },
  setPatchVariable: function(n, v) {
    return this._self.setPatchVariable(n, v);
  },
  createLinkFrom: function(other) {
    return world.createDirectedLink(other, this._self);
  },
  createLinksFrom: function(others) {
    return world.createReverseDirectedLinks(this._self, this.shuffle(others));
  },
  createLinkTo: function(other) {
    return world.createDirectedLink(this._self, other);
  },
  createLinksTo: function(others) {
    return world.createDirectedLinks(this._self, this.shuffle(others));
  },
  createLinkWith: function(other) {
    return world.createUndirectedLink(this._self, other);
  },
  createLinksWith: function(others) {
    return world.createUndirectedLinks(this._self, this.shuffle(others));
  },
  other: function(agentSet) {
    var filteredAgents, self;
    self = this._self;
    filteredAgents = agentSet.items.filter(function(o) {
      return o !== self;
    });
    return new Agents(filteredAgents, agentSet.breed);
  },
  shuffle: function(agents) {
    var iter, result;
    result = [];
    iter = new Shufflerator(agents.items);
    while (iter.hasNext()) {
      result.push(iter.next());
    }
    return new Agents(result, agents.breed);
  }
};

Agents = (function() {
  function Agents(items, breed) {
    this.items = items;
    this.breed = breed;
  }

  Agents.prototype.toString = function() {
    return "(" + this.items.length + " " + this.breed.name + ")";
  };

  Agents.prototype.sort = function() {
    if (this.items.length === 0) {
      return this.items;
    } else if (this.items[0] instanceof Link) {
      return this.items.sort(Links.compare);
    } else {
      throw new Error("We don't know how to sort your kind here!");
    }
  };

  return Agents;

})();

Iterator = (function() {
  function Iterator(agents) {
    this.agents = agents;
  }

  Iterator.prototype.i = 0;

  Iterator.prototype.hasNext = function() {
    return this.i < this.agents.length;
  };

  Iterator.prototype.next = function() {
    var result;
    result = this.agents[this.i];
    this.i = this.i + 1;
    return result;
  };

  return Iterator;

})();

Shufflerator = (function() {
  function Shufflerator(agents) {
    this.agents = agents;
    this.agents = this.agents.slice(0);
    this.fetch();
  }

  Shufflerator.prototype.i = 0;

  Shufflerator.prototype.nextOne = null;

  Shufflerator.prototype.hasNext = function() {
    return this.nextOne !== null;
  };

  Shufflerator.prototype.next = function() {
    var result;
    result = this.nextOne;
    this.fetch();
    return result;
  };

  Shufflerator.prototype.fetch = function() {
    var r;
    if (this.i >= this.agents.length) {
      this.nextOne = null;
    } else {
      if (this.i < this.agents.length - 1) {
        r = this.i + Random.nextInt(this.agents.length - this.i);
        this.nextOne = this.agents[r];
        this.agents[r] = this.agents[this.i];
      } else {
        this.nextOne = this.agents[this.i];
      }
      this.i = this.i + 1;
    }
  };

  return Shufflerator;

})();

Prims = {
  fd: function(n) {
    return AgentSet.self().fd(n);
  },
  bk: function(n) {
    return AgentSet.self().fd(-n);
  },
  right: function(n) {
    return AgentSet.self().right(n);
  },
  left: function(n) {
    return AgentSet.self().right(-n);
  },
  setXY: function(x, y) {
    return AgentSet.self().setXY(x, y);
  },
  getNeighbors: function() {
    return AgentSet.self().getNeighbors();
  },
  getNeighbors4: function() {
    return AgentSet.self().getNeighbors4();
  },
  sprout: function(n, breedName) {
    return AgentSet.self().sprout(n, breedName);
  },
  hatch: function(n, breedName) {
    return AgentSet.self().hatch(n, breedName);
  },
  patch: function(x, y) {
    return world.getPatchAt(x, y);
  },
  randomXcor: function() {
    return world.minPxcor - 0.5 + Random.nextDouble() * (world.maxPxcor - world.minPxcor + 1);
  },
  randomYcor: function() {
    return world.minPycor - 0.5 + Random.nextDouble() * (world.maxPycor - world.minPycor + 1);
  },
  shadeOf: function(c1, c2) {
    return Math.floor(c1 / 10) === Math.floor(c2 / 10);
  },
  equality: function(a, b) {
    if (a === void 0 || b === void 0) {
      throw new Error("Checking equality on undefined is an invalid condition");
    }
    if (a === b) {
      return true;
    } else if (typeIsArray(a) && typeIsArray(b)) {
      return a.length === b.length && a.every(function(elem, i) {
        return Prims.equality(elem, b[i]);
      });
    } else if (a instanceof Agents && b instanceof Agents) {
      return a.items.length === b.items.length && a.items.every(function(elem) {
        return __indexOf.call(b.items, elem) >= 0;
      });
    } else {
      return false;
    }
  },
  scaleColor: function(color, number, min, max) {
    var perc, tempmax, tempval;
    color = Math.floor(color / 10) * 10;
    perc = 0.0;
    if (min > max) {
      if (number < max) {
        perc = 1.0;
      } else if (number > min) {
        perc = 0.0;
      } else {
        tempval = min - number;
        tempmax = min - max;
        perc = tempval / tempmax;
      }
    } else {
      if (number > max) {
        perc = 1.0;
      } else if (number < min) {
        perc = 0.0;
      } else {
        tempval = number - min;
        tempmax = max - min;
        perc = tempval / tempmax;
      }
    }
    perc *= 10;
    if (perc >= 9.9999) {
      perc = 9.9999;
    }
    if (perc < 0) {
      perc = 0;
    }
    return color + perc;
  },
  random: function(n) {
    var truncated;
    truncated = n >= 0 ? Math.floor(n) : Math.ceil(n);
    if (truncated === 0) {
      return 0;
    } else if (truncated > 0) {
      return Random.nextLong(truncated);
    } else {
      return -Random.nextLong(-truncated);
    }
  },
  randomFloat: function(n) {
    return n * Random.nextDouble();
  },
  list: function() {
    var xs;
    xs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return xs;
  },
  item: function(n, xs) {
    return xs[n];
  },
  first: function(xs) {
    return xs[0];
  },
  last: function(xs) {
    return xs[xs.length - 1];
  },
  fput: function(x, xs) {
    return [x].concat(xs);
  },
  lput: function(x, xs) {
    var result;
    result = xs.slice(0);
    result.push(x);
    return result;
  },
  butFirst: function(xs) {
    return xs.slice(1);
  },
  butLast: function(xs) {
    return xs.slice(0, xs.length - 1);
  },
  length: function(xs) {
    return xs.length;
  },
  _int: function(n) {
    if (n < 0) {
      return Math.ceil(n);
    } else {
      return Math.floor(n);
    }
  },
  mod: function(a, b) {
    return ((a % b) + b) % b;
  },
  precision: function(n, places) {
    var multiplier, result;
    multiplier = Math.pow(10, places);
    result = Math.floor(n * multiplier + 0.5) / multiplier;
    if (places > 0) {
      return result;
    } else {
      return Math.round(result);
    }
  },
  max: function(xs) {
    return Math.max.apply(Math, xs);
  },
  min: function(xs) {
    return Math.min.apply(Math, xs);
  },
  mean: function(xs) {
    return this.sum(xs) / xs.length;
  },
  sum: function(xs) {
    return xs.reduce((function(a, b) {
      return a + b;
    }), 0);
  },
  sort: function(xs) {
    return xs.sort();
  },
  removeDuplicates: function(xs) {
    var key, result, value, _i, _ref2, _results;
    result = {};
    for (key = _i = 0, _ref2 = xs.length; 0 <= _ref2 ? _i < _ref2 : _i > _ref2; key = 0 <= _ref2 ? ++_i : --_i) {
      result[xs[key]] = xs[key];
    }
    _results = [];
    for (key in result) {
      value = result[key];
      _results.push(value);
    }
    return _results;
  },
  clearOutput: function() {
    var outputArea = document.getElementById('output');
    while(outputArea.childNodes.length > 0) {
      outputArea.removeChild(outputArea.childNodes[0]);
    }
  },
  outputPrint: function(x) {
    var outputArea = document.getElementById('output');
    outputArea.appendChild(document.createTextNode(x + '\n'));
  },
  patchSet: function() {
    var inputs, recurse, result;
    inputs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    result = [];
    recurse = function(inputs) {
      var agent, input, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = inputs.length; _i < _len; _i++) {
        input = inputs[_i];
        if (typeIsArray(input)) {
          _results.push(recurse(input));
        } else if (input instanceof Patch) {
          _results.push(result.push(input));
        } else {
          _results.push((function() {
            var _j, _len1, _ref2, _results1;
            _ref2 = input.items;
            _results1 = [];
            for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
              agent = _ref2[_j];
              if (!(__indexOf.call(result, agent) >= 0)) {
                _results1.push(result.push(agent));
              } else {
                _results1.push(void 0);
              }
            }
            return _results1;
          })());
        }
      }
      return _results;
    };
    recurse(inputs);
    return new Agents(result);
  }
};

Globals = {
  vars: [],
  init: function(n) {
    var x;
    return this.vars = (function() {
      var _i, _results;
      _results = [];
      for (x = _i = 0; 0 <= n ? _i < n : _i > n; x = 0 <= n ? ++_i : --_i) {
        _results.push(0);
      }
      return _results;
    })();
  },
  clear: function(n) {
    var i, _i, _ref2;
    for (i = _i = n, _ref2 = this.vars.length; n <= _ref2 ? _i < _ref2 : _i > _ref2; i = n <= _ref2 ? ++_i : --_i) {
      this.vars[i] = 0;
    }
  },
  getGlobal: function(n) {
    return this.vars[n];
  },
  setGlobal: function(n, v) {
    return this.vars[n] = v;
  }
};

TurtlesOwn = {
  vars: [],
  init: function(n) {
    var x;
    return this.vars = (function() {
      var _i, _ref2, _results;
      _results = [];
      for (x = _i = 0, _ref2 = n - 1; 0 <= _ref2 ? _i <= _ref2 : _i >= _ref2; x = 0 <= _ref2 ? ++_i : --_i) {
        _results.push(0);
      }
      return _results;
    })();
  }
};

PatchesOwn = {
  vars: [],
  init: function(n) {
    var x;
    return this.vars = (function() {
      var _i, _ref2, _results;
      _results = [];
      for (x = _i = 0, _ref2 = n - 1; 0 <= _ref2 ? _i <= _ref2 : _i >= _ref2; x = 0 <= _ref2 ? ++_i : --_i) {
        _results.push(0);
      }
      return _results;
    })();
  }
};

Dump = function(x) {
  var x2;
  if (typeIsArray(x)) {
    return "[" + ((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = x.length; _i < _len; _i++) {
        x2 = x[_i];
        _results.push(Dump(x2));
      }
      return _results;
    })()).join(" ") + "]";
  } else {
    return "" + x;
  }
};

Trig = {
  squash: function(x) {
    if (StrictMath.abs(x) < 3.2e-15) {
      return 0;
    } else {
      return x;
    }
  },
  sin: function(degrees) {
    return this.squash(StrictMath.sin(StrictMath.toRadians(degrees)));
  },
  cos: function(degrees) {
    return this.squash(StrictMath.cos(StrictMath.toRadians(degrees)));
  },
  unsquashedSin: function(degrees) {
    return StrictMath.sin(StrictMath.toRadians(degrees));
  },
  unsquashedCos: function(degrees) {
    return StrictMath.cos(StrictMath.toRadians(degrees));
  }
};

Breed = (function() {
  function Breed(name, singular, _shape) {
    this.name = name;
    this.singular = singular;
    this._shape = _shape != null ? _shape : false;
  }

  Breed.prototype.shape = function() {
    if (this._shape) {
      return this._shape;
    } else {
      return Breeds.get("TURTLES")._shape;
    }
  };

  Breed.prototype.vars = [];

  return Breed;

})();

Breeds = {
  breeds: [new Breed("TURTLES", "turtle", "default"), new Breed("LINKS", "link", "default")],
  add: function(name, singular) {
    return this.breeds.push(new Breed(name, singular));
  },
  get: function(name) {
    return (this.breeds.filter(function(b) {
      return b.name === name;
    }))[0];
  },
  setDefaultShape: function(agents, shape) {
    return agents.breed._shape = shape.toLowerCase();
  }
};

Topology = (function() {
  function Topology() {}

  Topology.prototype.wrap = function(pos, min, max) {
    var result;
    if (pos >= max) {
      return min + ((pos - max) % (max - min));
    } else if (pos < min) {
      result = max - ((min - pos) % (max - min));
      if (result < max) {
        return result;
      } else {
        return min;
      }
    } else {
      return pos;
    }
  };

  Topology.prototype.getNeighbors = function(pxcor, pycor) {
    var patch;
    return new Agents((function() {
      var _i, _len, _ref2, _results;
      _ref2 = this._getNeighbors(pxcor, pycor);
      _results = [];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        patch = _ref2[_i];
        if (patch !== false) {
          _results.push(patch);
        }
      }
      return _results;
    }).call(this));
  };

  Topology.prototype._getNeighbors = function(pxcor, pycor) {
    if (pxcor === this.maxPxcor && pxcor === this.minPxcor) {
      if ((pycor === this.maxPycor && pycor === this.minPycor)([])) {

      } else {
        return [this.getPatchNorth(pxcor, pycor), this.getPatchSouth(pxcor, pycor)];
      }
    } else if (pycor === this.maxPycor && pycor === this.minPycor) {
      return [this.getPatchEast(pxcor, pycor), this.getPatchWest(pxcor, pycor)];
    } else {
      return [this.getPatchNorth(pxcor, pycor), this.getPatchEast(pxcor, pycor), this.getPatchSouth(pxcor, pycor), this.getPatchWest(pxcor, pycor), this.getPatchNorthEast(pxcor, pycor), this.getPatchSouthEast(pxcor, pycor), this.getPatchSouthWest(pxcor, pycor), this.getPatchNorthWest(pxcor, pycor)];
    }
  };

  Topology.prototype.getNeighbors4 = function(pxcor, pycor) {
    var patch;
    return new Agents((function() {
      var _i, _len, _ref2, _results;
      _ref2 = this._getNeighbors4(pxcor, pycor);
      _results = [];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        patch = _ref2[_i];
        if (patch !== false) {
          _results.push(patch);
        }
      }
      return _results;
    }).call(this));
  };

  Topology.prototype._getNeighbors4 = function(pxcor, pycor) {
    if (pxcor === this.maxPxcor && pxcor === this.minPxcor) {
      if ((pycor === this.maxPycor && pycor === this.minPycor)([])) {

      } else {
        return [this.getPatchNorth(pxcor, pycor), this.getPatchSouth(pxcor, pycor)];
      }
    } else if (pycor === this.maxPycor && pycor === this.minPycor) {
      return [this.getPatchEast(pxcor, pycor), this.getPatchWest(pxcor, pycor)];
    } else {
      return [this.getPatchNorth(pxcor, pycor), this.getPatchEast(pxcor, pycor), this.getPatchSouth(pxcor, pycor), this.getPatchWest(pxcor, pycor)];
    }
  };

  Topology.prototype.distanceXY = function(x1, y1, x2, y2) {
    return StrictMath.sqrt(StrictMath.pow(this.shortestX(x1, x2), 2) + StrictMath.pow(this.shortestY(y1, y2), 2));
  };

  Topology.prototype.distance = function(x1, y1, agent) {
    if (agent instanceof Turtle) {
      return this.distanceXY(x1, y1, agent.xcor(), agent.ycor());
    } else if (agent instanceof Patch) {
      return this.distanceXY(x1, y1, agent.pxcor, agent.pycor);
    }
  };

  Topology.prototype.towards = function(x1, y1, x2, y2) {
    var dx, dy;
    dx = this.shortestX(x1, x2);
    dy = this.shortestY(y1, y2);
    if (dx === 0) {
      if (dy >= 0) {
        return 0;
      } else {
        return 180;
      }
    } else if (dy === 0) {
      if (dx >= 0) {
        return 90;
      } else {
        return 270;
      }
    } else {
      return (270 + StrictMath.toDegrees(Math.PI + StrictMath.atan2(-dy, dx))) % 360;
    }
  };

  Topology.prototype.midpointx = function(x1, x2) {
    return this.wrap((x1 + (x1 + this.shortestX(x1, x2))) / 2, world.minPxcor - 0.5, world.maxPxcor + 0.5);
  };

  Topology.prototype.midpointy = function(y1, y2) {
    return this.wrap((y1 + (y1 + this.shortestY(y1, y2))) / 2, world.minPycor - 0.5, world.maxPycor + 0.5);
  };

  Topology.prototype.inRadius = function(origin, x, y, agents, radius) {
    var dx, dy, height, maxDX, maxDY, minDX, minDY, p, r, result, t, width, _i, _j, _k, _len, _ref2;
    result = [];
    r = Math.ceil(radius);
    width = world.width() / 2;
    height = world.height() / 2;
    if (r < width || !world.wrappingAllowedInX) {
      minDX = -r;
      maxDX = r;
    } else {
      maxDX = StrictMath.floor(width);
      minDX = -Math.ceil(width - 1);
    }
    if (r < height || !world.wrappingAllowedInY) {
      minDY = -r;
      maxDY = r;
    } else {
      maxDY = StrictMath.floor(height);
      minDY = -Math.ceil(height - 1);
    }
    for (dy = _i = minDY; minDY <= maxDY ? _i <= maxDY : _i >= maxDY; dy = minDY <= maxDY ? ++_i : --_i) {
      for (dx = _j = minDX; minDX <= maxDX ? _j <= maxDX : _j >= maxDX; dx = minDX <= maxDX ? ++_j : --_j) {
        p = origin.patchAt(dx, dy);
        if (p !== Nobody) {
          if (this.distanceXY(p.pxcor, p.pycor, x, y) <= radius && agents.items.filter(function(o) {
            return o === p;
          }).length > 0) {
            result.push(p);
          }
          _ref2 = p.turtlesHere().items;
          for (_k = 0, _len = _ref2.length; _k < _len; _k++) {
            t = _ref2[_k];
            if (this.distanceXY(t.xcor(), t.ycor(), x, y) <= radius && agents.items.filter(function(o) {
              return o === t;
            }).length > 0) {
              result.push(t);
            }
          }
        }
      }
    }
    return new Agents(result, agents.breed);
  };

  return Topology;

})();

Torus = (function(_super) {
  __extends(Torus, _super);

  function Torus(minPxcor, maxPxcor, minPycor, maxPycor) {
    this.minPxcor = minPxcor;
    this.maxPxcor = maxPxcor;
    this.minPycor = minPycor;
    this.maxPycor = maxPycor;
  }

  Torus.prototype.wrapX = function(pos) {
    return this.wrap(pos, this.minPxcor - 0.5, this.maxPxcor + 0.5);
  };

  Torus.prototype.wrapY = function(pos) {
    return this.wrap(pos, this.minPycor - 0.5, this.maxPycor + 0.5);
  };

  Torus.prototype.shortestX = function(x1, x2) {
    if (StrictMath.abs(x1 - x2) > world.width() / 2) {
      return (world.width() - StrictMath.abs(x1 - x2)) * (x2 > x1 ? -1 : 1);
    } else {
      return Math.abs(x1 - x2) * (x1 > x2 ? -1 : 1);
    }
  };

  Torus.prototype.shortestY = function(y1, y2) {
    if (StrictMath.abs(y1 - y2) > world.height() / 2) {
      return (world.height() - StrictMath.abs(y1 - y2)) * (y2 > y1 ? -1 : 1);
    } else {
      return Math.abs(y1 - y2) * (y1 > y2 ? -1 : 1);
    }
  };

  Torus.prototype.diffuse = function(vn, amount) {
    var diffusalSum, diffusallyOrderedNeighbors, n, patch, pxcor, pycor, scratch, x, _i, _j, _len, _len1, _ref2, _ref3, _results;
    scratch = (function() {
      var _i, _ref2, _results;
      _results = [];
      for (x = _i = 0, _ref2 = world.width(); 0 <= _ref2 ? _i < _ref2 : _i > _ref2; x = 0 <= _ref2 ? ++_i : --_i) {
        _results.push([]);
      }
      return _results;
    })();
    _ref2 = world.patches().items;
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      patch = _ref2[_i];
      scratch[patch.pxcor - this.minPxcor][patch.pycor - this.minPycor] = patch.getPatchVariable(vn);
    }
    _ref3 = world.patches().items;
    _results = [];
    for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
      patch = _ref3[_j];
      pxcor = patch.pxcor;
      pycor = patch.pycor;
      diffusallyOrderedNeighbors = [this.getPatchSouthWest(pxcor, pycor), this.getPatchWest(pxcor, pycor), this.getPatchNorthWest(pxcor, pycor), this.getPatchSouth(pxcor, pycor), this.getPatchNorth(pxcor, pycor), this.getPatchSouthEast(pxcor, pycor), this.getPatchEast(pxcor, pycor), this.getPatchNorthEast(pxcor, pycor)];
      diffusalSum = ((function() {
        var _k, _len2, _results1;
        _results1 = [];
        for (_k = 0, _len2 = diffusallyOrderedNeighbors.length; _k < _len2; _k++) {
          n = diffusallyOrderedNeighbors[_k];
          _results1.push(scratch[n.pxcor - this.minPxcor][n.pycor - this.minPycor]);
        }
        return _results1;
      }).call(this)).reduce(function(a, b) {
        return a + b;
      });
      _results.push(patch.setPatchVariable(vn, patch.getPatchVariable(vn) * (1.0 - amount) + (diffusalSum / 8) * amount));
    }
    return _results;
  };

  Torus.prototype.getPatchNorth = function(pxcor, pycor) {
    if (pycor === this.maxPycor) {
      return world.getPatchAt(pxcor, this.minPycor);
    } else {
      return world.getPatchAt(pxcor, pycor + 1);
    }
  };

  Torus.prototype.getPatchSouth = function(pxcor, pycor) {
    if (pycor === this.minPycor) {
      return world.getPatchAt(pxcor, this.maxPycor);
    } else {
      return world.getPatchAt(pxcor, pycor - 1);
    }
  };

  Torus.prototype.getPatchEast = function(pxcor, pycor) {
    if (pxcor === this.maxPxcor) {
      return world.getPatchAt(this.minPxcor, pycor);
    } else {
      return world.getPatchAt(pxcor + 1, pycor);
    }
  };

  Torus.prototype.getPatchWest = function(pxcor, pycor) {
    if (pxcor === this.minPxcor) {
      return world.getPatchAt(this.maxPxcor, pycor);
    } else {
      return world.getPatchAt(pxcor - 1, pycor);
    }
  };

  Torus.prototype.getPatchNorthWest = function(pxcor, pycor) {
    if (pycor === this.maxPycor) {
      if (pxcor === this.minPxcor) {
        return world.getPatchAt(this.maxPxcor, this.minPycor);
      } else {
        return world.getPatchAt(pxcor - 1, this.minPycor);
      }
    } else if (pxcor === this.minPxcor) {
      return world.getPatchAt(this.maxPxcor, pycor + 1);
    } else {
      return world.getPatchAt(pxcor - 1, pycor + 1);
    }
  };

  Torus.prototype.getPatchSouthWest = function(pxcor, pycor) {
    if (pycor === this.minPycor) {
      if (pxcor === this.minPxcor) {
        return world.getPatchAt(this.maxPxcor, this.maxPycor);
      } else {
        return world.getPatchAt(pxcor - 1, this.maxPycor);
      }
    } else if (pxcor === this.minPxcor) {
      return world.getPatchAt(this.maxPxcor, pycor - 1);
    } else {
      return world.getPatchAt(pxcor - 1, pycor - 1);
    }
  };

  Torus.prototype.getPatchSouthEast = function(pxcor, pycor) {
    if (pycor === this.minPycor) {
      if (pxcor === this.maxPxcor) {
        return world.getPatchAt(this.minPxcor, this.maxPycor);
      } else {
        return world.getPatchAt(pxcor + 1, this.maxPycor);
      }
    } else if (pxcor === this.maxPxcor) {
      return world.getPatchAt(this.minPxcor, pycor - 1);
    } else {
      return world.getPatchAt(pxcor + 1, pycor - 1);
    }
  };

  Torus.prototype.getPatchNorthEast = function(pxcor, pycor) {
    if (pycor === this.maxPycor) {
      if (pxcor === this.maxPxcor) {
        return world.getPatchAt(this.minPxcor, this.minPycor);
      } else {
        return world.getPatchAt(pxcor + 1, this.minPycor);
      }
    } else if (pxcor === this.maxPxcor) {
      return world.getPatchAt(this.minPxcor, pycor + 1);
    } else {
      return world.getPatchAt(pxcor + 1, pycor + 1);
    }
  };

  return Torus;

})(Topology);

VertCylinder = (function(_super) {
  __extends(VertCylinder, _super);

  function VertCylinder(minPxcor, maxPxcor, minPycor, maxPycor) {
    this.minPxcor = minPxcor;
    this.maxPxcor = maxPxcor;
    this.minPycor = minPycor;
    this.maxPycor = maxPycor;
  }

  VertCylinder.prototype.shortestX = function(x1, x2) {
    if (StrictMath.abs(x1 - x2) > (1 + this.maxPxcor - this.minPxcor) / 2) {
      return (world.width() - StrictMath.abs(x1 - x2)) * (x2 > x1 ? -1 : 1);
    } else {
      return Math.abs(x1 - x2) * (x1 > x2 ? -1 : 1);
    }
  };

  VertCylinder.prototype.shortestY = function(y1, y2) {
    return Math.abs(y1 - y2) * (y1 > y2 ? -1 : 1);
  };

  VertCylinder.prototype.wrapX = function(pos) {
    return this.wrap(pos, this.minPxcor - 0.5, this.maxPxcor + 0.5);
  };

  VertCylinder.prototype.wrapY = function(pos) {
    if (pos >= this.maxPycor + 0.5 || pos <= this.minPycor - 0.5) {
      throw new TopologyInterrupt("Cannot move turtle beyond the world's edge.");
    } else {
      return pos;
    }
  };

  VertCylinder.prototype.getPatchNorth = function(pxcor, pycor) {
    return (pycor !== this.maxPycor) && world.getPatchAt(pxcor, pycor + 1);
  };

  VertCylinder.prototype.getPatchSouth = function(pxcor, pycor) {
    return (pycor !== this.minPycor) && world.getPatchAt(pxcor, pycor - 1);
  };

  VertCylinder.prototype.getPatchEast = function(pxcor, pycor) {
    if (pxcor === this.maxPxcor) {
      return world.getPatchAt(this.minPxcor, pycor);
    } else {
      return world.getPatchAt(pxcor + 1, pycor);
    }
  };

  VertCylinder.prototype.getPatchWest = function(pxcor, pycor) {
    if (pxcor === this.minPxcor) {
      return world.getPatchAt(this.maxPxcor, pycor);
    } else {
      return world.getPatchAt(pxcor - 1, pycor);
    }
  };

  VertCylinder.prototype.getPatchNorthWest = function(pxcor, pycor) {
    if (pycor === this.maxPycor) {
      return false;
    } else if (pxcor === this.minPxcor) {
      return world.getPatchAt(this.maxPxcor, pycor + 1);
    } else {
      return world.getPatchAt(pxcor - 1, pycor + 1);
    }
  };

  VertCylinder.prototype.getPatchSouthWest = function(pxcor, pycor) {
    if (pycor === this.minPycor) {
      return false;
    } else if (pxcor === this.minPxcor) {
      return world.getPatchAt(this.maxPxcor, pycor - 1);
    } else {
      return world.getPatchAt(pxcor - 1, pycor - 1);
    }
  };

  VertCylinder.prototype.getPatchSouthEast = function(pxcor, pycor) {
    if (pycor === this.minPycor) {
      return false;
    } else if (pxcor === this.maxPxcor) {
      return world.getPatchAt(this.minPxcor, pycor - 1);
    } else {
      return world.getPatchAt(pxcor + 1, pycor - 1);
    }
  };

  VertCylinder.prototype.getPatchNorthEast = function(pxcor, pycor) {
    if (pycor === this.maxPycor) {
      return false;
    } else if (pxcor === this.maxPxcor) {
      return world.getPatchAt(this.minPxcor, pycor + 1);
    } else {
      return world.getPatchAt(pxcor + 1, pycor + 1);
    }
  };

  VertCylinder.prototype.diffuse = function(vn, amount) {
    var diffuseVal, scratch, scratch2, x, xx, y, yy, _i, _j, _k, _ref2, _ref3, _results;
    yy = world.height();
    xx = world.width();
    scratch = (function() {
      var _i, _results;
      _results = [];
      for (x = _i = 0; 0 <= xx ? _i < xx : _i > xx; x = 0 <= xx ? ++_i : --_i) {
        _results.push((function() {
          var _j, _results1;
          _results1 = [];
          for (y = _j = 0; 0 <= yy ? _j < yy : _j > yy; y = 0 <= yy ? ++_j : --_j) {
            _results1.push(world.getPatchAt(x + this.minPxcor, y + this.minPycor).getPatchVariable(vn));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    }).call(this);
    scratch2 = (function() {
      var _i, _results;
      _results = [];
      for (x = _i = 0; 0 <= xx ? _i < xx : _i > xx; x = 0 <= xx ? ++_i : --_i) {
        _results.push((function() {
          var _j, _results1;
          _results1 = [];
          for (y = _j = 0; 0 <= yy ? _j < yy : _j > yy; y = 0 <= yy ? ++_j : --_j) {
            _results1.push(0);
          }
          return _results1;
        })());
      }
      return _results;
    })();
    for (y = _i = yy, _ref2 = yy * 2; yy <= _ref2 ? _i < _ref2 : _i > _ref2; y = yy <= _ref2 ? ++_i : --_i) {
      for (x = _j = xx, _ref3 = xx * 2; xx <= _ref3 ? _j < _ref3 : _j > _ref3; x = xx <= _ref3 ? ++_j : --_j) {
        diffuseVal = (scratch[x - xx][y - yy] / 8) * amount;
        if (y > yy && y < (yy * 2) - 1) {
          scratch2[x - xx][y - yy] += scratch[x - xx][y - yy] - (8 * diffuseVal);
          scratch2[(x - 1) % xx][(y - 1) % yy] += diffuseVal;
          scratch2[(x - 1) % xx][y % yy] += diffuseVal;
          scratch2[(x - 1) % xx][(y + 1) % yy] += diffuseVal;
          scratch2[x % xx][(y + 1) % yy] += diffuseVal;
          scratch2[x % xx][(y - 1) % yy] += diffuseVal;
          scratch2[(x + 1) % xx][(y - 1) % yy] += diffuseVal;
          scratch2[(x + 1) % xx][y % yy] += diffuseVal;
          scratch2[(x + 1) % xx][(y + 1) % yy] += diffuseVal;
        } else if (y === yy) {
          scratch2[x - xx][y - yy] += scratch[x - xx][y - yy] - (5 * diffuseVal);
          scratch2[(x - 1) % xx][y % yy] += diffuseVal;
          scratch2[(x - 1) % xx][(y + 1) % yy] += diffuseVal;
          scratch2[x % xx][(y + 1) % yy] += diffuseVal;
          scratch2[(x + 1) % xx][y % yy] += diffuseVal;
          scratch2[(x + 1) % xx][(y + 1) % yy] += diffuseVal;
        } else {
          scratch2[x - xx][y - yy] += scratch[x - xx][y - yy] - (5 * diffuseVal);
          scratch2[(x - 1) % xx][y % yy] += diffuseVal;
          scratch2[(x - 1) % xx][(y - 1) % yy] += diffuseVal;
          scratch2[x % xx][(y - 1) % yy] += diffuseVal;
          scratch2[(x + 1) % xx][y % yy] += diffuseVal;
          scratch2[(x + 1) % xx][(y - 1) % yy] += diffuseVal;
        }
      }
    }
    _results = [];
    for (y = _k = 0; 0 <= yy ? _k < yy : _k > yy; y = 0 <= yy ? ++_k : --_k) {
      _results.push((function() {
        var _l, _results1;
        _results1 = [];
        for (x = _l = 0; 0 <= xx ? _l < xx : _l > xx; x = 0 <= xx ? ++_l : --_l) {
          _results1.push(world.getPatchAt(x + this.minPxcor, y + this.minPycor).setPatchVariable(vn, scratch2[x][y]));
        }
        return _results1;
      }).call(this));
    }
    return _results;
  };

  return VertCylinder;

})(Topology);

HorzCylinder = (function(_super) {
  __extends(HorzCylinder, _super);

  function HorzCylinder(minPxcor, maxPxcor, minPycor, maxPycor) {
    this.minPxcor = minPxcor;
    this.maxPxcor = maxPxcor;
    this.minPycor = minPycor;
    this.maxPycor = maxPycor;
  }

  HorzCylinder.prototype.shortestX = function(x1, x2) {
    return Math.abs(x1 - x2) * (x1 > x2 ? -1 : 1);
  };

  HorzCylinder.prototype.shortestY = function(y1, y2) {
    if (StrictMath.abs(y1 - y2) > (1 + this.maxPycor - this.minPycor) / 2) {
      return (world.height() - Math.abs(y1 - y2)) * (y2 > y1 ? -1 : 1);
    } else {
      return Math.abs(y1 - y2) * (y1 > y2 ? -1 : 1);
    }
  };

  HorzCylinder.prototype.wrapX = function(pos) {
    if (pos >= this.maxPxcor + 0.5 || pos <= this.minPxcor - 0.5) {
      throw new TopologyInterrupt("Cannot move turtle beyond the world's edge.");
    } else {
      return pos;
    }
  };

  HorzCylinder.prototype.wrapY = function(pos) {
    return this.wrap(pos, this.minPycor - 0.5, this.maxPycor + 0.5);
  };

  HorzCylinder.prototype.getPatchEast = function(pxcor, pycor) {
    return (pxcor !== this.maxPxcor) && world.getPatchAt(pxcor + 1, pycor);
  };

  HorzCylinder.prototype.getPatchWest = function(pxcor, pycor) {
    return (pxcor !== this.minPxcor) && world.getPatchAt(pxcor - 1, pycor);
  };

  HorzCylinder.prototype.getPatchNorth = function(pxcor, pycor) {
    if (pycor === this.maxPycor) {
      return world.getPatchAt(pxcor, this.minPycor);
    } else {
      return world.getPatchAt(pxcor, pycor + 1);
    }
  };

  HorzCylinder.prototype.getPatchSouth = function(pxcor, pycor) {
    if (pycor === this.minPycor) {
      return world.getPatchAt(pxcor, this.maxPycor);
    } else {
      return world.getPatchAt(pxcor, pycor - 1);
    }
  };

  HorzCylinder.prototype.getPatchNorthWest = function(pxcor, pycor) {
    if (pxcor === this.minPxcor) {
      return false;
    } else if (pycor === this.maxPycor) {
      return world.getPatchAt(pxcor - 1, this.minPycor);
    } else {
      return world.getPatchAt(pxcor - 1, pycor + 1);
    }
  };

  HorzCylinder.prototype.getPatchSouthWest = function(pxcor, pycor) {
    if (pxcor === this.minPxcor) {
      return false;
    } else if (pycor === this.minPycor) {
      return world.getPatchAt(pxcor - 1, this.maxPycor);
    } else {
      return world.getPatchAt(pxcor - 1, pycor - 1);
    }
  };

  HorzCylinder.prototype.getPatchSouthEast = function(pxcor, pycor) {
    if (pxcor === this.maxPxcor) {
      return false;
    } else if (pycor === this.minPycor) {
      return world.getPatchAt(pxcor + 1, this.maxPycor);
    } else {
      return world.getPatchAt(pxcor + 1, pycor - 1);
    }
  };

  HorzCylinder.prototype.getPatchNorthEast = function(pxcor, pycor) {
    if (pxcor === this.maxPxcor) {
      return false;
    } else if (pycor === this.maxPycor) {
      return world.getPatchAt(pxcor + 1, this.minPycor);
    } else {
      return world.getPatchAt(pxcor + 1, pycor + 1);
    }
  };

  HorzCylinder.prototype.diffuse = function(vn, amount) {
    var diffuseVal, scratch, scratch2, x, xx, y, yy, _i, _j, _k, _ref2, _ref3, _results;
    yy = world.height();
    xx = world.width();
    scratch = (function() {
      var _i, _results;
      _results = [];
      for (x = _i = 0; 0 <= xx ? _i < xx : _i > xx; x = 0 <= xx ? ++_i : --_i) {
        _results.push((function() {
          var _j, _results1;
          _results1 = [];
          for (y = _j = 0; 0 <= yy ? _j < yy : _j > yy; y = 0 <= yy ? ++_j : --_j) {
            _results1.push(world.getPatchAt(x + this.minPxcor, y + this.minPycor).getPatchVariable(vn));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    }).call(this);
    scratch2 = (function() {
      var _i, _results;
      _results = [];
      for (x = _i = 0; 0 <= xx ? _i < xx : _i > xx; x = 0 <= xx ? ++_i : --_i) {
        _results.push((function() {
          var _j, _results1;
          _results1 = [];
          for (y = _j = 0; 0 <= yy ? _j < yy : _j > yy; y = 0 <= yy ? ++_j : --_j) {
            _results1.push(0);
          }
          return _results1;
        })());
      }
      return _results;
    })();
    for (y = _i = yy, _ref2 = yy * 2; yy <= _ref2 ? _i < _ref2 : _i > _ref2; y = yy <= _ref2 ? ++_i : --_i) {
      for (x = _j = xx, _ref3 = xx * 2; xx <= _ref3 ? _j < _ref3 : _j > _ref3; x = xx <= _ref3 ? ++_j : --_j) {
        diffuseVal = (scratch[x - xx][y - yy] / 8) * amount;
        if (x > xx && x < (xx * 2) - 1) {
          scratch2[x - xx][y - yy] += scratch[x - xx][y - yy] - (8 * diffuseVal);
          scratch2[(x - 1) % xx][(y - 1) % yy] += diffuseVal;
          scratch2[(x - 1) % xx][y % yy] += diffuseVal;
          scratch2[(x - 1) % xx][(y + 1) % yy] += diffuseVal;
          scratch2[x % xx][(y + 1) % yy] += diffuseVal;
          scratch2[x % xx][(y - 1) % yy] += diffuseVal;
          scratch2[(x + 1) % xx][(y - 1) % yy] += diffuseVal;
          scratch2[(x + 1) % xx][y % yy] += diffuseVal;
          scratch2[(x + 1) % xx][(y + 1) % yy] += diffuseVal;
        } else if (x === xx) {
          scratch2[x - xx][y - yy] += scratch[x - xx][y - yy] - (5 * diffuseVal);
          scratch2[x % xx][(y + 1) % yy] += diffuseVal;
          scratch2[x % xx][(y - 1) % yy] += diffuseVal;
          scratch2[(x + 1) % xx][(y - 1) % yy] += diffuseVal;
          scratch2[(x + 1) % xx][y % yy] += diffuseVal;
          scratch2[(x + 1) % xx][(y + 1) % yy] += diffuseVal;
        } else {
          scratch2[x - xx][y - yy] += scratch[x - xx][y - yy] - (5 * diffuseVal);
          scratch2[x % xx][(y + 1) % yy] += diffuseVal;
          scratch2[x % xx][(y - 1) % yy] += diffuseVal;
          scratch2[(x - 1) % xx][(y - 1) % yy] += diffuseVal;
          scratch2[(x - 1) % xx][y % yy] += diffuseVal;
          scratch2[(x - 1) % xx][(y + 1) % yy] += diffuseVal;
        }
      }
    }
    _results = [];
    for (y = _k = 0; 0 <= yy ? _k < yy : _k > yy; y = 0 <= yy ? ++_k : --_k) {
      _results.push((function() {
        var _l, _results1;
        _results1 = [];
        for (x = _l = 0; 0 <= xx ? _l < xx : _l > xx; x = 0 <= xx ? ++_l : --_l) {
          _results1.push(world.getPatchAt(x + this.minPxcor, y + this.minPycor).setPatchVariable(vn, scratch2[x][y]));
        }
        return _results1;
      }).call(this));
    }
    return _results;
  };

  return HorzCylinder;

})(Topology);

Box = (function(_super) {
  __extends(Box, _super);

  function Box(minPxcor, maxPxcor, minPycor, maxPycor) {
    this.minPxcor = minPxcor;
    this.maxPxcor = maxPxcor;
    this.minPycor = minPycor;
    this.maxPycor = maxPycor;
  }

  Box.prototype.shortestX = function(x1, x2) {
    return Math.abs(x1 - x2) * (x1 > x2 ? -1 : 1);
  };

  Box.prototype.shortestY = function(y1, y2) {
    return Math.abs(y1 - y2) * (y1 > y2 ? -1 : 1);
  };

  Box.prototype.wrapX = function(pos) {
    if (pos >= this.maxPxcor + 0.5 || pos <= this.minPxcor - 0.5) {
      throw new TopologyInterrupt("Cannot move turtle beyond the worlds edge.");
    } else {
      return pos;
    }
  };

  Box.prototype.wrapY = function(pos) {
    if (pos >= this.maxPycor + 0.5 || pos <= this.minPycor - 0.5) {
      throw new TopologyInterrupt("Cannot move turtle beyond the worlds edge.");
    } else {
      return pos;
    }
  };

  Box.prototype.getPatchNorth = function(pxcor, pycor) {
    return (pycor !== this.maxPycor) && world.getPatchAt(pxcor, pycor + 1);
  };

  Box.prototype.getPatchSouth = function(pxcor, pycor) {
    return (pycor !== this.minPycor) && world.getPatchAt(pxcor, pycor - 1);
  };

  Box.prototype.getPatchEast = function(pxcor, pycor) {
    return (pxcor !== this.maxPxcor) && world.getPatchAt(pxcor + 1, pycor);
  };

  Box.prototype.getPatchWest = function(pxcor, pycor) {
    return (pxcor !== this.minPxcor) && world.getPatchAt(pxcor - 1, pycor);
  };

  Box.prototype.getPatchNorthWest = function(pxcor, pycor) {
    return (pycor !== this.maxPycor) && (pxcor !== this.minPxcor) && world.getPatchAt(pxcor - 1, pycor + 1);
  };

  Box.prototype.getPatchSouthWest = function(pxcor, pycor) {
    return (pycor !== this.minPycor) && (pxcor !== this.minPxcor) && world.getPatchAt(pxcor - 1, pycor - 1);
  };

  Box.prototype.getPatchSouthEast = function(pxcor, pycor) {
    return (pycor !== this.minPycor) && (pxcor !== this.maxPxcor) && world.getPatchAt(pxcor + 1, pycor - 1);
  };

  Box.prototype.getPatchNorthEast = function(pxcor, pycor) {
    return (pycor !== this.maxPycor) && (pxcor !== this.maxPxcor) && world.getPatchAt(pxcor + 1, pycor + 1);
  };

  Box.prototype.diffuse = function(vn, amount) {
    var diffuseVal, scratch, scratch2, x, xx, y, yy, _i, _j, _k, _results;
    yy = world.height();
    xx = world.width();
    scratch = (function() {
      var _i, _results;
      _results = [];
      for (x = _i = 0; 0 <= xx ? _i < xx : _i > xx; x = 0 <= xx ? ++_i : --_i) {
        _results.push((function() {
          var _j, _results1;
          _results1 = [];
          for (y = _j = 0; 0 <= yy ? _j < yy : _j > yy; y = 0 <= yy ? ++_j : --_j) {
            _results1.push(world.getPatchAt(x + this.minPxcor, y + this.minPycor).getPatchVariable(vn));
          }
          return _results1;
        }).call(this));
      }
      return _results;
    }).call(this);
    scratch2 = (function() {
      var _i, _results;
      _results = [];
      for (x = _i = 0; 0 <= xx ? _i < xx : _i > xx; x = 0 <= xx ? ++_i : --_i) {
        _results.push((function() {
          var _j, _results1;
          _results1 = [];
          for (y = _j = 0; 0 <= yy ? _j < yy : _j > yy; y = 0 <= yy ? ++_j : --_j) {
            _results1.push(0);
          }
          return _results1;
        })());
      }
      return _results;
    })();
    for (y = _i = 0; 0 <= yy ? _i < yy : _i > yy; y = 0 <= yy ? ++_i : --_i) {
      for (x = _j = 0; 0 <= xx ? _j < xx : _j > xx; x = 0 <= xx ? ++_j : --_j) {
        diffuseVal = (scratch[x][y] / 8) * amount;
        if (y > 0 && y < yy - 1 && x > 0 && x < xx - 1) {
          scratch2[x][y] += scratch[x][y] - (8 * diffuseVal);
          scratch2[x - 1][y - 1] += diffuseVal;
          scratch2[x - 1][y] += diffuseVal;
          scratch2[x - 1][y + 1] += diffuseVal;
          scratch2[x][y + 1] += diffuseVal;
          scratch2[x][y - 1] += diffuseVal;
          scratch2[x + 1][y - 1] += diffuseVal;
          scratch2[x + 1][y] += diffuseVal;
          scratch2[x + 1][y + 1] += diffuseVal;
        } else if (y > 0 && y < yy - 1) {
          if (x === 0) {
            scratch2[x][y] += scratch[x][y] - (5 * diffuseVal);
            scratch2[x][y + 1] += diffuseVal;
            scratch2[x][y - 1] += diffuseVal;
            scratch2[x + 1][y - 1] += diffuseVal;
            scratch2[x + 1][y] += diffuseVal;
            scratch2[x + 1][y + 1] += diffuseVal;
          } else {
            scratch2[x][y] += scratch[x][y] - (5 * diffuseVal);
            scratch2[x][y + 1] += diffuseVal;
            scratch2[x][y - 1] += diffuseVal;
            scratch2[x - 1][y - 1] += diffuseVal;
            scratch2[x - 1][y] += diffuseVal;
            scratch2[x - 1][y + 1] += diffuseVal;
          }
        } else if (x > 0 && x < xx - 1) {
          if (y === 0) {
            scratch2[x][y] += scratch[x][y] - (5 * diffuseVal);
            scratch2[x - 1][y] += diffuseVal;
            scratch2[x - 1][y + 1] += diffuseVal;
            scratch2[x][y + 1] += diffuseVal;
            scratch2[x + 1][y] += diffuseVal;
            scratch2[x + 1][y + 1] += diffuseVal;
          } else {
            scratch2[x][y] += scratch[x][y] - (5 * diffuseVal);
            scratch2[x - 1][y] += diffuseVal;
            scratch2[x - 1][y - 1] += diffuseVal;
            scratch2[x][y - 1] += diffuseVal;
            scratch2[x + 1][y] += diffuseVal;
            scratch2[x + 1][y - 1] += diffuseVal;
          }
        } else if (x === 0) {
          if (y === 0) {
            scratch2[x][y] += scratch[x][y] - (3 * diffuseVal);
            scratch2[x][y + 1] += diffuseVal;
            scratch2[x + 1][y] += diffuseVal;
            scratch2[x + 1][y + 1] += diffuseVal;
          } else {
            scratch2[x][y] += scratch[x][y] - (3 * diffuseVal);
            scratch2[x][y - 1] += diffuseVal;
            scratch2[x + 1][y] += diffuseVal;
            scratch2[x + 1][y - 1] += diffuseVal;
          }
        } else if (y === 0) {
          scratch2[x][y] += scratch[x][y] - (3 * diffuseVal);
          scratch2[x][y + 1] += diffuseVal;
          scratch2[x - 1][y] += diffuseVal;
          scratch2[x - 1][y + 1] += diffuseVal;
        } else {
          scratch2[x][y] += scratch[x][y] - (3 * diffuseVal);
          scratch2[x][y - 1] += diffuseVal;
          scratch2[x - 1][y] += diffuseVal;
          scratch2[x - 1][y - 1] += diffuseVal;
        }
      }
    }
    _results = [];
    for (y = _k = 0; 0 <= yy ? _k < yy : _k > yy; y = 0 <= yy ? ++_k : --_k) {
      _results.push((function() {
        var _l, _results1;
        _results1 = [];
        for (x = _l = 0; 0 <= xx ? _l < xx : _l > xx; x = 0 <= xx ? ++_l : --_l) {
          _results1.push(world.getPatchAt(x + this.minPxcor, y + this.minPycor).setPatchVariable(vn, scratch2[x][y]));
        }
        return _results1;
      }).call(this));
    }
    return _results;
  };

  return Box;

})(Topology);

Layouts = {
  layoutSpring: function(nodeSet, linkSet, spr, len, rep) {
    var agt, ang, ax, ay, degCount, degCount1, degCount2, dist, div, dx, dy, f, fx, fy, i, j, limit, link, newx, newy, nodeCount, perturbAmt, t, t1, t1Index, t2, t2Index, tMap, _i, _j, _k, _l, _len, _len1, _len2, _m, _n, _ref2, _ref3, _ref4, _ref5, _results;
    nodeCount = nodeSet.items.length;
    if (nodeCount === 0) {
      return;
    }
    ax = [];
    ay = [];
    tMap = [];
    degCount = (function() {
      var _i, _results;
      _results = [];
      for (i = _i = 0; 0 <= nodeCount ? _i < nodeCount : _i > nodeCount; i = 0 <= nodeCount ? ++_i : --_i) {
        _results.push(0);
      }
      return _results;
    })();
    agt = [];
    i = 0;
    _ref2 = AgentSet.shuffle(nodeSet).items;
    for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
      t = _ref2[_i];
      agt[i] = t;
      tMap[t.id] = i;
      ax[i] = 0.0;
      ay[i] = 0.0;
      i++;
    }
    _ref3 = linkSet.items;
    for (_j = 0, _len1 = _ref3.length; _j < _len1; _j++) {
      link = _ref3[_j];
      t1 = link.end1;
      t2 = link.end2;
      if (tMap[t1.id] !== void 0) {
        t1Index = tMap[t1.id];
        degCount[t1Index]++;
      }
      if (tMap[t2.id] !== void 0) {
        t2Index = tMap[t2.id];
        degCount[t2Index]++;
      }
    }
    _ref4 = linkSet.items;
    for (_k = 0, _len2 = _ref4.length; _k < _len2; _k++) {
      link = _ref4[_k];
      dx = 0;
      dy = 0;
      t1 = link.end1;
      t2 = link.end2;
      t1Index = -1;
      degCount1 = 0;
      if (tMap[t1.id] !== void 0) {
        t1Index = tMap[t1.id];
        degCount1 = degCount[t1Index];
      }
      t2Index = -1;
      degCount2 = 0;
      if (tMap[t2.id] !== void 0) {
        t2Index = tMap[t2.id];
        degCount2 = degCount[t2Index];
      }
      dist = t1.distance(t2);
      div = (degCount1 + degCount2) / 2.0;
      div = Math.max(div, 1.0);
      if (dist === 0) {
        dx += (spr * len) / div;
      } else {
        f = spr * (dist - len) / div;
        dx = dx + (f * (t2.xcor() - t1.xcor()) / dist);
        dy = dy + (f * (t2.ycor() - t1.ycor()) / dist);
      }
      if (t1Index !== -1) {
        ax[t1Index] += dx;
        ay[t1Index] += dy;
      }
      if (t2Index !== -1) {
        ax[t2Index] -= dx;
        ay[t2Index] -= dy;
      }
    }
    for (i = _l = 0; 0 <= nodeCount ? _l < nodeCount : _l > nodeCount; i = 0 <= nodeCount ? ++_l : --_l) {
      t1 = agt[i];
      for (j = _m = _ref5 = i + 1; _ref5 <= nodeCount ? _m < nodeCount : _m > nodeCount; j = _ref5 <= nodeCount ? ++_m : --_m) {
        t2 = agt[j];
        dx = 0.0;
        dy = 0.0;
        div = (degCount[i] + degCount[j]) / 2.0;
        div = Math.max(div, 1.0);
        if (t2.xcor() === t1.xcor() && t2.ycor() === t1.ycor()) {
          ang = 360 * Random.nextDouble();
          dx = -(rep / div * Trig.sin(StrictMath.toRadians(ang)));
          dy = -(rep / div * Trig.cos(StrictMath.toRadians(ang)));
        } else {
          dist = t1.distance(t2);
          f = rep / (dist * dist) / div;
          dx = -(f * (t2.xcor() - t1.xcor()) / dist);
          dy = -(f * (t2.ycor() - t1.ycor()) / dist);
        }
        ax[i] += dx;
        ay[i] += dy;
        ax[j] -= dx;
        ay[j] -= dy;
      }
    }
    if (nodeCount > 1) {
      perturbAmt = (world.width() + world.height()) / 1.0e10;
      ax[0] += Random.nextDouble() * perturbAmt - perturbAmt / 2.0;
      ay[0] += Random.nextDouble() * perturbAmt - perturbAmt / 2.0;
    }
    limit = (world.width() + world.height()) / 50.0;
    _results = [];
    for (i = _n = 0; 0 <= nodeCount ? _n < nodeCount : _n > nodeCount; i = 0 <= nodeCount ? ++_n : --_n) {
      t = agt[i];
      fx = ax[i];
      fy = ay[i];
      if (fx > limit) {
        fx = limit;
      } else if (fx < -limit) {
        fx = -limit;
      }
      if (fy > limit) {
        fy = limit;
      } else if (fy < -limit) {
        fy = -limit;
      }
      newx = t.xcor() + fx;
      newy = t.ycor() + fy;
      if (newx > world.maxPxcor) {
        newx = world.maxPxcor;
      } else if (newx < world.minPxcor) {
        newx = world.minPxcor;
      }
      if (newy > world.maxPycor) {
        newy = world.maxPycor;
      } else if (newy < world.minPycor) {
        newy = world.minPycor;
      }
      _results.push(t.setXY(newx, newy));
    }
    return _results;
  }
};
